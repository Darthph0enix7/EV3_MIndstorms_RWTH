% --- HAUPTPROGRAMM ---
clear all;
b = EV3();
b.connect('usb');

mx = b.motorA;
my = b.motorB;
mc = b.motorC;

% Grundeinstellungen der Motoren
mx.setProperties('speedRegulation', 'On', 'limitMode', 'Tacho', 'brakeMode', 'Brake');
my.setProperties('speedRegulation', 'On', 'limitMode', 'Tacho', 'brakeMode', 'Brake');
mc.setProperties('speedRegulation', 'On', 'limitMode', 'Tacho', 'brakeMode', 'Brake');

% WICHTIG: Wir definieren die aktuelle Position als den absoluten Nullpunkt (0,0)
mx.resetTachoCount();
my.resetTachoCount();
mc.resetTachoCount();

% --- KONFIGURATION ---
S.ratioX = 4;        % Dein Getriebe an Achse X
S.ratioY = 1;        % Dein Getriebe an Achse Y
S.Durchmesser = 4.32;
S.maxSpeed = 40;     % Ziehgeschwindigkeit
S.penSpeed = 10;     % Stiftgeschwindigkeit
S.penUpAngle = 0;    % Stift Oben
S.penDownAngle = 60; % Stift Unten (Winkel anpassen wenn nötig)

% --- DAS MOTIV: DER KREIS ---
t = 0:0.1:2*pi;
x = 10 + 5 * cos(t);
y = 10 + 5 * sin(t);

% Zeige Vorschau am PC
figure; plot(x, y); title('Roboter Pfad'); axis equal; grid on;

% Starte den Zeichenvorgang
drawShape(mx, my, mc, x, y, S);

% Ende
mx.stop();
my.stop();
mc.stop();
b.disconnect();


% --- DIE FUNKTION ---
function drawShape(mx, my, mc, xPathCm, yPathCm, S)
    
    % HIER IST DIE ÄNDERUNG: Faktor -1 bei Y für die Invertierung
    degPerCmX = (360 * S.ratioX) / (pi * S.Durchmesser);
    degPerCmY = -1 * (360 * S.ratioY) / (pi * S.Durchmesser);

    % Pfad in Grad umrechnen (Absolutwerte)
    xPathDeg = round(xPathCm * degPerCmX);
    yPathDeg = round(yPathCm * degPerCmY);

    % Deltas berechnen (Schritte)
    dX = diff(xPathDeg);
    dY = diff(yPathDeg);

    numSteps = length(dX);
    
    % --- VORBERECHNUNG DER GESCHWINDIGKEITEN ---
    powerX_List = zeros(1, numSteps);
    powerY_List = zeros(1, numSteps);
    limitX_List = abs(dX);
    limitY_List = abs(dY);

    for k = 1:numSteps
        changeX = dX(k);
        changeY = dY(k);
        
        if abs(changeX) < 1 && abs(changeY) < 1
            powerX_List(k) = 0;
            powerY_List(k) = 0;
            continue;
        end
        
        maxDist = max(abs(changeX), abs(changeY));
        
        % Vektor-Normalisierung für gerade Linien
        spdX = (abs(changeX) / maxDist) * S.maxSpeed;
        spdY = (abs(changeY) / maxDist) * S.maxSpeed;
        
        % Mindestkraft gegen Reibung
        if spdX < 5 && spdX > 0; spdX = 5; end
        if spdY < 5 && spdY > 0; spdY = 5; end
        
        powerX_List(k) = round(spdX * sign(changeX));
        powerY_List(k) = round(spdY * sign(changeY));
    end

    % --- AUSFÜHRUNG ---

    % 1. Stift Hoch (Sicherheit)
    mc.power = -S.penSpeed;
    mc.limitValue = abs(S.penUpAngle - S.penDownAngle); 
    mc.resetTachoCount();
    mc.start();
    mc.waitFor();

    % 2. Zum ersten Punkt fahren (Von 0,0 aus)
    startX = xPathDeg(1);
    startY = yPathDeg(1);

    mx.limitValue = abs(startX);
    my.limitValue = abs(startY);
    
    % Wir müssen hier manuell prüfen, ob startX positiv oder negativ ist für die Power
    if startX ~= 0; mx.power = 20 * sign(startX); else; mx.power = 0; end
    if startY ~= 0; my.power = 20 * sign(startY); else; my.power = 0; end

    mx.resetTachoCount();
    my.resetTachoCount();

    if abs(startX) > 0; mx.start(); end
    if abs(startY) > 0; my.start(); end
    mx.waitFor();
    my.waitFor();

    % 3. Stift Runter
    mc.power = S.penSpeed;
    mc.limitValue = abs(S.penUpAngle - S.penDownAngle);
    mc.resetTachoCount();
    mc.start();
    mc.waitFor();

    % 4. Das Zeichnen (Loop)
    for i = 1:numSteps
        limX = limitX_List(i);
        limY = limitY_List(i);
        powX = powerX_List(i);
        powY = powerY_List(i);
        
        if limX == 0 && limY == 0
            continue;
        end
        
        mx.limitValue = limX;
        my.limitValue = limY;
        mx.power = powX;
        my.power = powY;
        
        mx.resetTachoCount();
        my.resetTachoCount();
        
        if limX > 0; mx.start(); end
        if limY > 0; my.start(); end
        
        if limX > 0; mx.waitFor(); end
        if limY > 0; my.waitFor(); end
    end

    % 5. Stift Hoch
    mc.power = -S.penSpeed;
    mc.limitValue = abs(S.penUpAngle - S.penDownAngle);
    mc.resetTachoCount();
    mc.start();
    mc.waitFor();
    
    

    % 6. Zurück zum Ursprung (0,0) fahren
    % Wir sind jetzt am letzten Punkt (endX, endY) relativ zu 0,0.
    % Um zurückzukommen, fahren wir genau diese Strecke rückwärts.
    
    endX = xPathDeg(end);
    endY = yPathDeg(end);

    mx.limitValue = abs(endX);
    my.limitValue = abs(endY);
    
    % Invertieren (-endX) um zurückzufahren
    if endX ~= 0; mx.power = 30 * sign(-endX); else; mx.power = 0; end
    if endY ~= 0; my.power = 30 * sign(-endY); else; my.power = 0; end
    
    mx.resetTachoCount();
    my.resetTachoCount();
    
    if abs(endX) > 0; mx.start(); end
    if abs(endY) > 0; my.start(); end
    
    mx.waitFor();
    my.waitFor();
    
end